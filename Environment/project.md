### A. 解的个数
#### 算法分析
##### **Part 1 朴素DP**

首先发现一个很好的性质：

每行是递增的并且一行$m$个元素，取值只能在$[0,m]$中选

那么必然该行至多有一个位置与后一个位置相差2，其余的都只相差1
　
由此可以列出一个简单的$DP$：

$dp[i][j]$表示第$i$行没有出现过的数是$j$的方案数

$dp[i][j]=\sum_{k=0}^{j+1}dp[i-1][k]$

至于上界为什么是$j+1$可以手动模拟一下，假设这行$j$没有出现过，上一行试一试$j-1$、$j$、$j+1$、$j+2$，发现大于$j+1$的就不合法了

略微优化一下就变成了$dp[i][j]=dp[i-1][j+1]+dp[i][j-1]$

##### **Part 2 转化为图形**

发现这个$DP$像极了组合数公式，把它套用在坐标系里就是这个样子
![iwUEt0.png](https://s1.ax1x.com/2018/10/18/iwUEt0.png)
自上而下第$i$行，从左往右第$j$列的点就表示$dp[i][j]$，其指向的点就表示可以转移
这样仍然不太好处理，我们继续转化：
![iwUwBd.png](https://s1.ax1x.com/2018/10/18/iwUwBd.png)
还是不好看，给它对称一下：
![iwUt1O.png](https://s1.ax1x.com/2018/10/18/iwUt1O.png)

##### **Part 3 挖掘组合意义**

这么一看，不就是**从原点出发，只能向右或向上走，不接触直线A,B，到达点(n+m+1,n)的路径条数**吗！

直线$A:y=x+1$，直线$B:y=x-(m+2)$

##### **Part 4 计算**

这种格路数计算（如两双手）都可以考虑采用容斥计数

不考虑其他限制，原点到$x,y$的方案数是$C_{x+y}^x$

考虑不合法方案是什么：如依次经过$AABBAAAABB$

把它缩一下：$ABAB$
　
可以发现不合法方案要么以$A$开头要么以$B$开头

表示为首次跨越的直线是$A$还是$B$

所以：**答案=总方案数 - A开头的方案数 - B开头的方案数**
　
$x=n+m+1,y=n$，把$(x,y)$沿$A$对称得到$(x',y')=(y-1,x+1)$

**每条从$(0,0)$到$(x',y')$的路径都依次对应一条以A结尾或者以AB结尾的路径！**

![此处输入图片的描述](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fwcmwpd2irj30id0gudgm.jpg)
上面是一条以$A$结尾的路径
![此处输入图片的描述](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fwcmwqn12rj30j60i4jsb.jpg)
上面是一条以$AB$结尾的路径
所以，总共的不合法方案是

- A
- B
- AB
- BA
- ABA
- BAB
- ABAB
- BABA
- ...

为了减去以$A$开头的方案，需要**减去以A,AB结尾的方案，加上以BA,BAB结尾的方案，减去....**
那么实现方式是：**把(x,y)沿A翻折，减去答案；将翻折过的点沿B翻着，加上答案；再沿A翻折...**
　
同理计算以$B$开头的方案，就是先沿$B$折就好了

具体细节的话沿着$A$折是$(x,y)->(y-1,x+1)$，沿着$B$折是$(x,y)->(y+(m+2),x-(m+2))$
完美解决本题！

### B. 城市联通
#### 算法分析

了解矩阵树的应该都清楚，矩阵树求的是：$\sum\limits_{T}\prod\limits_{e \in T}p_e$

而这题求的是：$\sum\limits_{T}(\prod\limits_{e\in T}p_e \prod\limits_{e\notin T} (1-p_e))$

通俗地将：枚举每个树，属于这个树边出现的概率$\times$非树边出现的概率

$$\sum\limits_{T}(\prod\limits_{e\in T}p_e \prod\limits_{e\notin T} (1-p_e))$$
$$=\sum\limits_{T}(\prod\limits_{e\in T}p_e \frac{\prod_{e}(1-P_e)}{\prod_{e\in T}(1-P_e)})$$$$=\prod\limits_{e}(1-p_e)(\sum\limits_{T}\prod\limits_{e\in T}\frac{pe}{(1-pe)})$$

化成标准形式套模板就好了

时间复杂度 $O(n^3)$


### C. 子序列计数
#### 算法一
这题难就难在怎么由$[l,r]$推向$[l,r+1]$

考虑他们之间的增量就是新增的$[l,r+1],[l+1,r+1],\ldots,[r+1,r+1]$这$r-l+2$个区间的最小值之和。

考虑求出$[l,r+1]$的最小值位置是$p$,那么所有左端点在$[l,p]$之间的区间答案都是$a[p]$

贡献就是$a[p]\times(p-l+1)$,这一部分可以用$rmq$求最小值处理

考虑剩下的左端点在$[p+1,r+1]$的区间

设$f[l][r]$表示以$r$为右端点,左端点在$[l,r]$的区间的答案(要求的就是$f[p+1][r+1]$)

记录一下$pre_i$表示从$i$向前第一个比$i$小的数的位置(这个可以用单调栈$O(n)$求出)

那么左端点在$[pre_r,r]$的区间最小值都是$a[r]$

那么就有$f[l][r]=f[l][pre_r]+a_r\times(r-pre_r)$。

可以发现$dp$增量只和$r$自身有关,所以可以去掉$l$那一维

因为最终一定会存在一个点$x$,满足$pre_x=p$

那么$f_{r+1}=a_{r+1}\times(r+1-pre_{r+1})+\ldots+a_x\times(x-p)+f_p$

我们可以发现$f_{r+1}-f_p$就是原来要求的$f[p+1][r+1]$

这样我们就可以预处理出$f$,然后就可以$O(1)$完成转移了

删除的话我们就减去$[l,r-1]\to[l,r]$的增量就好了

至于在左边加,就对称处理就好了

时间复杂度$O(n\log n+n\sqrt n)$

#### 算法二

我们假设区间$[l,r]$的最小值的位置是$p$

那么对于左端点在$[l,p]$,右端点在$[p,r]$的区间最小值都是$a[p]$

这一部分的贡献是$a[p]\times(p-l+1)\times(r-p+1)$

我们还没有统计$[l,p-1]$和$[p+1,r]$的答案

在莫队算法中我们已经知道

因为最终一定会存在一个点$x$,满足$pre_x=p$
那么$f_{r+1}=a_{r+1}\times(r+1-pre_{r+1})+\ldots+a_x\times(x-p)+f_p$
我们可以发现$f_{r+1}-f_p$就是原来要求的$f[p+1][r+1]$

然而这个是以$r+1$为右端点,左端点在$(p,r+1]$的答案

在这里我们就要考虑左端点在$(p,x]$,右端点在$[x,r]$的全部答案

对于点$r$,所有以$r$为右端点,左端点在$(p,r]$的区间答案是$f_r-f_p$

对于点$r-1$,所有以$r-1$为右端点,左端点在$(p,r-1]$的区间答案是$f_{r-1}-f_p$
$\ldots$
对于点$p+1$,所有以$p+1$为右端点,左端点在$(p,p+1]$的区间答案是$f_{p+1}-f_p$

设$g_i=\sum_{j=1}^if_j$,通过观察发现,这一部分的答案就是$g_r-g_p-f_p\times(r-p)$
同样的,$p$左边的情况也是类似

时间复杂度 $O(n\log n)$。
